package com.plovdev.bot.modules.beerjes.utils;

import com.plovdev.bot.modules.beerjes.TakeProfitLevel;
import com.plovdev.bot.modules.beerjes.TradeService;
import com.plovdev.bot.modules.databases.UserEntity;
import com.plovdev.bot.modules.exceptions.InvalidParametresException;
import com.plovdev.bot.modules.models.OrderResult;
import com.plovdev.bot.modules.models.SettingsService;
import com.plovdev.bot.modules.models.SymbolInfo;
import com.plovdev.bot.modules.parsers.Signal;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;

/**
 * –ö–ª–∞—Å—Å, –ø—Ä–µ–¥–æ—Å—Ç–∞–ª—è—é—â–∏–π –æ–±—â–∏–µ —É—Ç–∏–ª–∏—Ç–∞—Ä–Ω—ã–µ —Å—Ä–µ–¥—Å—Ç–≤–∞ –ø–æ —Ä–∞–±–æ—Ç–µ —Å –±–∏—Ä–∂–∞–º.
 */
public class BeerjUtils {
    private static final BigDecimal MIN_ORDER_SIZE = new BigDecimal("2.0");
    private static final SettingsService service = new SettingsService();
    private static final Logger logger = LoggerFactory.getLogger("BeerjUtils");

    /**
     * –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä.
     */
    private BeerjUtils() {
    }

    /**
     * –ù–∞—Ö–æ–¥–∏—Ç –ø—Ä–æ—Ü–µ–Ω—Ç—ã –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
     *
     * @param percents –∫–æ–ª-–≤–æ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤
     * @param number   –Ω–∞—á–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –¥–ª—è –ø–æ–∏—Å–∫–∞.
     * @return –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–Ω—ã–µ –ø—Ä–æ—Ü–µ–Ω—Ç—ã –≤ USDT.
     */
    public static BigDecimal getPercent(BigDecimal percents, BigDecimal number) {
        return (number.divide(new BigDecimal("100.0"), 10, RoundingMode.HALF_UP)).multiply(percents);
    }


    //–°–ª–æ–≤–∞—Ä—å –º–æ–Ω–µ—Ç-–∏—Å–∫–ª—é—á–µ–Ω–∏–π –¥–ª—è BitGet
    private static final Map<String, String> bitGetTokens = loadBgTokens();
    private static final Map<String, String> bitunixTokens = loadBuTokens();
    //–ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã —Å –Ω–∞–∑–≤–∞–Ω–∏–π –±–∏—Ä–∂
    public static final String BITGET = "bitget";
    public static final String BITUNIX = "bitunix";

    private static Map<String, String> loadBgTokens() {
        Map<String, String> map = new HashMap<>();
        map.put("shib", "shib");
        map.put("luna", "luna");
        map.put("lunc", "lunc");
        map.put("floki", "floki");
        map.put("pepe", "pepe");
        map.put("beam", "beam");
        map.put("agi", "agi");
        map.put("cheems", "1mcheems");
        map.put("tst", "tstbsc");
        map.put("lay", "play");
        return map;
    }

    private static Map<String, String> loadBuTokens() {
        Map<String, String> map = new HashMap<>();
        map.put("shib", "1000shib");
        map.put("luna", "luna2");
        map.put("lunc", "1000lunc");
        map.put("floki", "1000floki");
        map.put("pepe", "1000pepe");
        map.put("beam", "beamx");
        map.put("agi", "agix");
        map.put("cheems", "1000cheems");
        map.put("tst", "tst");
        map.put("lay", "klay");
        return map;
    }

    /**
     * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã –ø–æ–¥ —É–∫–∞–∑–∞–Ω–Ω—É—é –±–∏—Ä–∂—É, –ø—Ä–∏–º–µ—Ä:
     * BitGet - SHIBUSDT
     * BitUnix - 1000SHIBUSDT
     * –≤—Ö–æ–¥ - SHIBUSDT, exchange - bitunix
     * –≤—ã—Ö–æ–¥ - 1000SHINUSDT
     *
     * @param baseName –ø–∞—Ä–∞ –∏–∑ —Å–∏–≥–Ω–∞–ª–∞.
     * @param exch     –±–∏—Ä–∂–∞ –¥–ª—è –∫–æ—Ç–æ—Ä–æ–π –±—Ä–∞—Ç—å –Ω–∞–∑–≤–∞–Ω–∏–µ.
     * @return –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø–∞—Ä–∞ –ø–æ–¥ –Ω—É–∂–Ω—É—é –±–∏—Ä–∂—É.
     */
    public static String getExchangeCoin(String baseName, String exch) {
        String name = baseName.toUpperCase().replace("USDT", "");
        logger.info("–ü–æ–ª—É—á–µ–Ω–∞ –º–æ–Ω–µ—Ç–∞: {}", name);

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±–∏—Ä–∂–∏
        if (exch.equalsIgnoreCase(BITGET)) {
            logger.info("–°–º–æ—Ç—Ä–º–∏ –Ω–∞ —Å–ø–∏—Å–æ–∫ bitget");
            //BitGet –º–æ–Ω–µ—Ç—ã
            return parseExchange(bitGetTokens, name).toUpperCase();
        } else if (exch.equalsIgnoreCase(BITUNIX)) {
            logger.info("–°–º–æ—Ç—Ä–º–∏ –Ω–∞ —Å–ø–∏—Å–æ–∫ bitunix");
            //BitUnix –º–æ–Ω–µ—Ç—ã
            return parseExchange(bitunixTokens, name).toUpperCase();
        } else {
            throw new InvalidParametresException("Unknow exchange: " + exch);
        }
    }

    /**
     * –ò—â–µ—Ç –º–æ–Ω–µ—Ç—É –≤ —Å–ø–∏—Å–∫–µ.
     *
     * @param map  —Å–ø–∏—Å–æ–∫ –º–æ–Ω–µ—Ç —É –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –±–∏—Ä–∂–∏.
     * @param name –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã –∏–∑ —Å–∏–≥–Ω–∞–ª–∞
     * @return –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã –≤ –Ω—É–∂–Ω–æ–π –±–∏—Ä–∂–∏.
     */
    private static String parseExchange(Map<String, String> map, String name) {
        name = name.replace("1000", "").toLowerCase();
        logger.info("–ò—â–µ–º –ø–∞—Ä—É –≤ –±–∏—Ä–∂–µ, coin: {}", name);

        if (map.containsKey(name)) {
            String coin = map.get(name);
            String total = coin + "USDT";
            logger.info("–ù–∞–π–¥–µ–Ω–∞ –º–æ–Ω–µ—Ç–∞: {}", total);
            return total;
        } else return name.toUpperCase() + "USDT";
    }

    /**
     * –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ—Ç –æ–±—â–∏–π —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –ø–æ —É—Ä–æ–≤–Ω—è–º —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç–∞ —Å —É—á—ë—Ç–æ–º:
     * - –ù–∞—Å—Ç—Ä–æ–µ–∫ –∞–¥–º–∏–Ω–∞ (–ø—Ä–æ—Ü–µ–Ω—Ç–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ)
     * - –¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ—Å—Ç–∏ —Ä–∞–∑–º–µ—Ä–æ–≤ –æ—Ä–¥–µ—Ä–æ–≤ (–≤ USDT)
     * - –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏ (LONG/SHORT)
     * - –¢–µ–∫—É—â–µ–π —Ä—ã–Ω–æ—á–Ω–æ–π —Ü–µ–Ω—ã (—Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –Ω–µ–≤–∞–ª–∏–¥–Ω—ã—Ö —Ç–µ–π–∫–æ–≤)
     *
     * @param signal        –°–∏–≥–Ω–∞–ª —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –∏ —Ü–µ–Ω–∞—Ö —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç–æ–≤
     * @param totalSize     –û–±—â–∏–π —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –≤ USDT (—Ü–µ–ª–æ–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ)
     * @param tpRatios      –°–ø–∏—Å–æ–∫ –ø—Ä–æ—Ü–µ–Ω—Ç–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–µ–π–∫–∞ (—Å—É–º–º–∞ = 100%)
     * @param currentPrice  –¢–µ–∫—É—â–∞—è —Ä—ã–Ω–æ—á–Ω–∞—è —Ü–µ–Ω–∞ (mark price)
     * @return –°–ø–∏—Å–æ–∫ –≤–∞–ª–∏–¥–Ω—ã—Ö —É—Ä–æ–≤–Ω–µ–π —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç–∞ —Å —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–º–∏ —Ä–∞–∑–º–µ—Ä–∞–º–∏
     */
    public static List<TakeProfitLevel> adjustTakeProfits(Signal signal, BigDecimal totalSize, List<BigDecimal> tpRatios, BigDecimal currentPrice, SymbolInfo symbolInfo) {
        int pricePlace = symbolInfo.getPricePlace();
        int volumePlace = symbolInfo.getVolumePlace();
        BigDecimal minOrderSize = symbolInfo.getMinTradeNum();

        List<TakeProfitLevel> result = new ArrayList<>();
        if (totalSize == null || totalSize.compareTo(BigDecimal.ZERO) <= 0) {
            logger.warn("Total size is null, or equal zero. returning...");
            return result;
        }

        List<BigDecimal> signalTargets = signal.getTargets();
        logger.info("Targets: {}", signalTargets);
        if (signalTargets == null || signalTargets.isEmpty() || tpRatios == null || tpRatios.isEmpty()) {
            logger.warn("Empty data: signal targets, tp ratios, returning...");
            return result;
        }

        boolean isLong = "LONG".equalsIgnoreCase(signal.getDirection());
        int levelsToUse = Math.min(tpRatios.size(), signalTargets.size());
        BigDecimal usedSize = BigDecimal.ZERO;
        logger.info("Data: isLong: {}, levelToUse: {}, volumePlace: {}, pricePlace: {}", isLong, levelsToUse, volumePlace, pricePlace);
        logger.info("Current price is: {}", currentPrice);

        // 1. –§–∏–ª—å—Ç—Ä—É–µ–º –∏ —Å–æ–∑–¥–∞—ë–º —É—Ä–æ–≤–Ω–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–∞–ª–∏–¥–Ω—ã—Ö —Ü–µ–Ω
        for (int i = 0; i < levelsToUse; i++) {
            BigDecimal tpPrice = signalTargets.get(i);
            if (tpPrice == null) continue;
            System.out.println(tpPrice);
            tpPrice = tpPrice.setScale(pricePlace, RoundingMode.HALF_EVEN);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å —Ü–µ–Ω—ã —Ç–µ–π–∫–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã
            logger.info("Take price: {}", tpPrice);
            boolean isValidPrice = (isLong && tpPrice.compareTo(currentPrice) > 0) || (!isLong && tpPrice.compareTo(currentPrice) < 0);

            if (!isValidPrice) {
                logger.warn("Price is invalid.");
                continue; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–µ —Ç–µ–π–∫–∏
            }

            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –≤ USDT –ø–æ –ø—Ä–æ—Ü–µ–Ω—Ç—É
            BigDecimal ratio = tpRatios.get(i);
            BigDecimal orderSize = totalSize.multiply(ratio).divide(BigDecimal.valueOf(100), 5, RoundingMode.HALF_UP);

            // –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ —Ü–µ–ª–æ–≥–æ —á–∏—Å–ª–∞ (–≤ –º–µ–Ω—å—à—É—é —Å—Ç–æ—Ä–æ–Ω—É, —á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ–≤—ã—Å–∏—Ç—å totalSize)
            BigDecimal integerSize = orderSize.setScale(volumePlace, RoundingMode.HALF_EVEN);

            if (integerSize.compareTo(minOrderSize) >= 0) {
                result.add(new TakeProfitLevel(integerSize, tpPrice));
                logger.info("Take size: {}", integerSize);
                usedSize = usedSize.add(integerSize);
            } else {
                result.add(new TakeProfitLevel(minOrderSize, tpPrice));
                logger.info("Take size is 1");
                usedSize = usedSize.add(minOrderSize);
            }
            // –ï—Å–ª–∏ —Ä–∞–∑–º–µ—Ä –º–µ–Ω—å—à–µ 1 USDT ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º (–Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç)
        }

        List<TakeProfitLevel> levels = reAdjustTakeProfits(totalSize, result, symbolInfo, currentPrice, signal.getDirection());
        if (levels.isEmpty()) {
            BigDecimal newPrice = currentPrice.multiply(new BigDecimal("0.01")).setScale(symbolInfo.getPricePlace(), RoundingMode.HALF_EVEN);
            levels.add(new TakeProfitLevel(totalSize, currentPrice.add(newPrice)));
            return levels;
        }

        return levels;
    }

    public static BigDecimal calculateNewStopPrice(String side, BigDecimal entry, BigDecimal offsetPercent, int pricePlace) {
        BigDecimal offsetMultiplier = offsetPercent.divide(new BigDecimal("100"), 15, RoundingMode.HALF_EVEN);
        logger.info("Calculating new stop price. Params: offsetMultyplier {}, side: {}, entry price: {}, offset percent: {}, price place: {}", offsetMultiplier, side, entry, offsetPercent, pricePlace);

        if ("SELL".equalsIgnoreCase(side) || "SHORT".equalsIgnoreCase(side)) {
            return entry.subtract(entry.multiply(offsetMultiplier)).setScale(pricePlace, RoundingMode.HALF_EVEN);
        } else if ("BUY".equalsIgnoreCase(side) || "LONG".equalsIgnoreCase(side)) {
            logger.info("Long position stop calculating...");
            return entry.add(entry.multiply(offsetMultiplier)).setScale(pricePlace, RoundingMode.HALF_EVEN);
        }
        return entry;
    }


    public static List<TakeProfitLevel> reAdjustTakeProfits(BigDecimal totalSize, List<TakeProfitLevel> takeProfitLevels, SymbolInfo info, BigDecimal currentPrice, String side) {
        List<TakeProfitLevel> levels = new ArrayList<>(takeProfitLevels);
        logger.info("üîÑ Starting re-adjustment. Total size: {}, Takes: {}",
                totalSize, levels);

        if (levels.isEmpty()) {
            logger.warn("No take profit levels to adjust");
            return levels;
        }

        // 1. –í—ã—á–∏—Å–ª—è–µ–º —Ç–µ–∫—É—â—É—é —Å—É–º–º—É –≤—Å–µ—Ö —Ç–µ–π–∫–æ–≤
        BigDecimal currentTotal = levels.stream()
                .map(TakeProfitLevel::getSize)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        logger.info("Current total: {}, Target total: {}", currentTotal, totalSize);

        // 2. –ï—Å–ª–∏ —Å—É–º–º–∞ —É–∂–µ —Ä–∞–≤–Ω–∞ totalSize - –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
        if (currentTotal.compareTo(totalSize) == 0) {
            BigDecimal muliplierUsed = BigDecimal.ZERO;
            logger.info("CT == TS, levels: {}", levels);
            for (TakeProfitLevel level : levels) {
                BigDecimal sizeMultiplier = info.getSizeMultiplier();
                BigDecimal size = level.getSize();
                logger.info("Size: {}, Size multiplier: {}", size, sizeMultiplier);
                if (!BeerjUtils.isMultiple(size, sizeMultiplier)) {
                    size = size.divide(sizeMultiplier, info.getVolumePlace(), RoundingMode.HALF_EVEN).multiply(sizeMultiplier);
                    if (size.compareTo(info.getMinTradeNum()) < 0) {
                        size = info.getMinTradeNum();
                    }
                    muliplierUsed = muliplierUsed.add(size);
                    level.setSize(size);
                }
            }
            if (muliplierUsed.compareTo(BigDecimal.ZERO) > 0) {
                TakeProfitLevel l1 = levels.getLast();
                l1.setSize(l1.getSize().add(totalSize.subtract(muliplierUsed)));
            }

            List<TakeProfitLevel> finalResilt = getTakeProfitLevels(info, levels);

            logger.info("Sum already equals total size, no adjustment needed");
            System.out.println("LEVELS: " + finalResilt);
            //return compareLevels(finalResilt, side);
            return finalResilt;
        }

        // 3. –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–Ω–∏—Ü—É
        BigDecimal difference = totalSize.subtract(currentTotal);
        logger.info("Difference to distribute: {}", difference);

        // 4. –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–Ω–∏—Ü—É
        if (difference.compareTo(BigDecimal.ZERO) > 0) {
            // –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Ä–∞–∑–Ω–∏—Ü—É
            levels = distributeAddition(levels, difference, totalSize, info.getVolumePlace());
        } else {
            // –ù—É–∂–Ω–æ —É–±—Ä–∞—Ç—å —Ä–∞–∑–Ω–∏—Ü—É
            levels = distributeSubtraction(levels, difference.abs(), totalSize, info.getVolumePlace());
        }

        if (levels.isEmpty()) {
            BigDecimal newPrice = currentPrice.multiply(new BigDecimal("0.01")).setScale(info.getPricePlace(), RoundingMode.HALF_EVEN);
            levels.add(new TakeProfitLevel(totalSize, currentPrice.add(newPrice)));
            return levels;
        }

        return reAdjustTakeProfits(totalSize, levels, info, currentPrice, side);
    }

    public static List<TakeProfitLevel> getTakeProfitLevels(SymbolInfo info, List<TakeProfitLevel> levels) {
        List<TakeProfitLevel> finalResilt = new ArrayList<>();
        for (int i = levels.size()-1; i >= 0; i--) {
            TakeProfitLevel level = levels.get(i);
            if (level.getSize().compareTo(info.getMinTradeNum()) < 0) {
                if (i-1 >= 0) {
                    TakeProfitLevel nextLevel = levels.get(i - 1);
                    nextLevel.setSize(nextLevel.getSize().add(level.getSize()));
                }
            } else {
                finalResilt.add(level);
            }
        }
        finalResilt = finalResilt.reversed();
        return finalResilt;
    }

    /**
     * –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–∞–∑–Ω–∏—Ü—ã –º–µ–∂–¥—É —Ç–µ–π–∫–∞–º–∏
     */
    private static List<TakeProfitLevel> distributeAddition(List<TakeProfitLevel> levels, BigDecimal amountToAdd, BigDecimal totalSize, int vol) {
        logger.info("‚ûï Distributing addition: {} across {} levels", amountToAdd, levels.size());

        List<TakeProfitLevel> result = new ArrayList<>();
        int levelsCount = levels.size();

        // –°–Ω–∞—á–∞–ª–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä–æ–≤–Ω—É (—Ü–µ–ª—ã–µ —á–∞—Å—Ç–∏)
        BigDecimal baseAddition = amountToAdd.divide(BigDecimal.valueOf(levelsCount), vol, RoundingMode.HALF_EVEN);
        BigDecimal remainder = amountToAdd.remainder(BigDecimal.valueOf(levelsCount));

        logger.info("Base addition: {}, Remainder: {}", baseAddition, remainder);

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–∞–∑–æ–≤–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ –≤—Å–µ–º —É—Ä–æ–≤–Ω—è–º
        for (TakeProfitLevel level : levels) {
            BigDecimal newSize = level.getSize().add(baseAddition);
            result.add(new TakeProfitLevel(newSize, level.getPrice()));
        }

        // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –æ—Å—Ç–∞—Ç–æ–∫ –ø–æ –æ–¥–Ω–æ–º—É –Ω–∞ –∫–∞–∂–¥—ã–π —É—Ä–æ–≤–µ–Ω—å (–Ω–∞—á–∏–Ω–∞—è —Å –ø–µ—Ä–≤–æ–≥–æ)
        if (remainder.compareTo(BigDecimal.ZERO) > 0) {
            logger.info("Distributing remainder: {}", remainder);
            for (int i = 0; i < remainder.intValue() && i < result.size(); i++) {
                TakeProfitLevel level = result.get(i);
                BigDecimal newSize = level.getSize().add(BigDecimal.ONE);
                level.setSize(newSize);
            }
        }

        // –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        return finalAdjustment(result, totalSize);
    }

    /**
     * –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ—Ç –≤—ã—á–∏—Ç–∞–Ω–∏–µ —Ä–∞–∑–Ω–∏—Ü—ã –º–µ–∂–¥—É —Ç–µ–π–∫–∞–º–∏
     */
    private static List<TakeProfitLevel> distributeSubtraction(List<TakeProfitLevel> levels, BigDecimal amountToSubtract, BigDecimal totalSize, int vol) {
        logger.info("‚ûñ Distributing subtraction: {} across {} levels", amountToSubtract, levels.size());

        List<TakeProfitLevel> result = new ArrayList<>(levels);
        BigDecimal remainingToSubtract = amountToSubtract;

        int iters = 0;

        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø–æ–∫–∞ –µ—Å—Ç—å —á—Ç–æ –≤—ã—á–∏—Ç–∞—Ç—å
        while (remainingToSubtract.compareTo(BigDecimal.ZERO) > 0 && !result.isEmpty()) {
            if (iters >= 100) {
                return new ArrayList<>();
            }
            // –°—á–∏—Ç–∞–µ–º —Å–∫–æ–ª—å–∫–æ –º–æ–∂–µ–º –≤—ã—á–∏—Ç–∞—Ç—å —Å –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è –∑–∞ —ç—Ç—É –∏—Ç–µ—Ä–∞—Ü–∏—é
            int subtractPerLevel = Math.min(
                    remainingToSubtract.divide(BigDecimal.valueOf(result.size()), vol, RoundingMode.DOWN).intValue(),
                    1 // –ú–∞–∫—Å–∏–º—É–º 1 –∑–∞ –∏—Ç–µ—Ä–∞—Ü–∏—é —á—Ç–æ–±—ã –Ω–µ —É–π—Ç–∏ –≤ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ —á–∏—Å–ª–∞
            );

            if (subtractPerLevel == 0) {
                subtractPerLevel = 1; // –ú–∏–Ω–∏–º—É–º 1 –µ—Å–ª–∏ –µ—Å—Ç—å —á—Ç–æ –≤—ã—á–∏—Ç–∞—Ç—å
            }

            logger.info("Subtracting {} per level, remaining: {}", subtractPerLevel, remainingToSubtract);

            // –í—ã—á–∏—Ç–∞–µ–º —Å –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è
            result = result.reversed();
            for (int i = 0; i < result.size() && remainingToSubtract.compareTo(BigDecimal.ZERO) > 0; i++) {
                TakeProfitLevel level = result.get(i);
                BigDecimal currentSize = level.getSize();

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ—Å–ª–µ –≤—ã—á–∏—Ç–∞–Ω–∏—è —Ä–∞–∑–º–µ—Ä –±—É–¥–µ—Ç –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º
                if (currentSize.compareTo(BigDecimal.ONE) >= 0) {
                    BigDecimal newSize = currentSize.subtract(BigDecimal.valueOf(subtractPerLevel));
                    level.setSize(newSize);
                    remainingToSubtract = remainingToSubtract.subtract(BigDecimal.valueOf(subtractPerLevel));
                }
            }
            result = result.reversed();

            // –£–±–∏—Ä–∞–µ–º —É—Ä–æ–≤–Ω–∏ —Å –Ω—É–ª–µ–≤—ã–º —Ä–∞–∑–º–µ—Ä–æ–º
            result.removeIf(level -> level.getSize().compareTo(BigDecimal.ZERO) <= 0);
            iters++;
        }

        return finalAdjustment(result, totalSize);
    }

    /**
     * –§–∏–Ω–∞–ª—å–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ —á—Ç–æ–±—ã —Å—É–º–º–∞ –±—ã–ª–∞ –ê–ë–°–û–õ–Æ–¢–ù–û —Ä–∞–≤–Ω–∞ totalSize
     */
    private static List<TakeProfitLevel> finalAdjustment(List<TakeProfitLevel> levels, BigDecimal totalSize) {
        BigDecimal currentTotal = levels.stream()
                .map(TakeProfitLevel::getSize)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal finalDifference = totalSize.subtract(currentTotal);
        System.out.println("Fial levels: " + levels);

        if (finalDifference.compareTo(BigDecimal.ZERO) == 0) {
            logger.info("‚úÖ Final adjustment: Sum equals total size");
            return levels;
        }

        logger.info("üîß Final adjustment needed: {}", finalDifference);

        // –ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º/—É–±–∏—Ä–∞–µ–º —Ä–∞–∑–Ω–∏—Ü—É —Å –ø–µ—Ä–≤–æ–≥–æ —É—Ä–æ–≤–Ω—è
        if (finalDifference.compareTo(BigDecimal.ZERO) > 0) {
            TakeProfitLevel firstLevel = levels.getFirst();
            BigDecimal newSize = firstLevel.getSize().add(finalDifference);
            firstLevel.setSize(newSize);
            logger.info("Added {} to first level", finalDifference);
        } else {
            TakeProfitLevel firstLevel = levels.getFirst();
            BigDecimal subtraction = finalDifference.abs();
            if (firstLevel.getSize().compareTo(subtraction) >= 0) {
                BigDecimal newSize = firstLevel.getSize().subtract(subtraction);
                firstLevel.setSize(newSize);
                logger.info("Subtracted {} from first level", subtraction);
            }
        }

        // –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        BigDecimal finalTotal = levels.stream()
                .map(TakeProfitLevel::getSize)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        logger.info("üéØ Final result: {} levels, total: {} (target: {})",
                levels.size(), finalTotal, totalSize);

        return levels;
    }


    public static List<TakeProfitLevel> getMarginLevels(List<TakeProfitLevel> tpLevels, BigDecimal margin) {
        BigDecimal totalMargin = BigDecimal.ZERO;
        for (TakeProfitLevel tp : tpLevels) totalMargin = totalMargin.add(tp.getSize());
        if (totalMargin.compareTo(margin) > 0) {
            List<TakeProfitLevel> subList = tpLevels.subList(0, tpLevels.size() - 1);
            return getMarginLevels(subList, margin);
        } else {
            return tpLevels;
        }
    }

    public static OrderResult valdateOpen(UserEntity user, Signal signal) {
        String srcFrom = signal.getSrc().toLowerCase();
        String strategy = user.getGroup().toLowerCase();
        logger.info("Validating user");
        logger.info("Src from: {}, user strategy: {}", srcFrom, strategy);

        if (srcFrom.equals("tg")) {
            if (strategy.equals("tv"))
                return new OrderResult(false, "none", signal.getSymbol(), "User group no right", List.of(), List.of());
        }
        if (srcFrom.equals("tv")) {
            if (strategy.equals("tg"))
                return new OrderResult(false, "none", signal.getSymbol(), "User group no right", List.of(), List.of());
        }
        if (!user.canOpenNewPositoin(signal)) return OrderResult.error("User: " + user.getTgId() + ", " + user.getTgName() + " already has active position for pair.", "none", signal.getSymbol());

        return OrderResult.ok("Ok", "0", signal.getSymbol());
    }

    public static List<TakeProfitLevel> compareLevels(List<TakeProfitLevel> levels, String side) {
        List<BigDecimal> sizes = new ArrayList<>();
        for (TakeProfitLevel l : levels) {
            sizes.add(l.getSize());
        }

        sizes.sort(Collections.reverseOrder()); // —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —É–±—ã–≤–∞–Ω–∏—é

        // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Å–µ —Ü–µ–Ω—ã –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
        List<BigDecimal> prices = new ArrayList<>();
        for (TakeProfitLevel l : levels) {
            prices.add(l.getPrice());
        }
        if (side.equalsIgnoreCase("long")) {
            prices.sort(Comparator.naturalOrder()); // —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é
        } else {
            prices.sort(Comparator.reverseOrder());
        }

        // –§–æ—Ä–º–∏—Ä—É–µ–º –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫: –∫ —Å–∞–º–æ–π –º–∞–ª–µ–Ω—å–∫–æ–π —Ü–µ–Ω–µ ‚Äî —Å–∞–º—ã–π –±–æ–ª—å—à–æ–π size, –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ
        List<TakeProfitLevel> result = new ArrayList<>();
        for (int i = 0; i < levels.size(); i++) {
            result.add(new TakeProfitLevel(sizes.get(i), prices.get(i)));
        }

        return result;
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ 1 —á–∏—Å–ª–æ –∫—Ä–æ—Ç–Ω–æ –¥—Ä—É–≥–æ–º—É.
     * @param value –≤—Ö–æ–¥–Ω–æ–µ —á–∏—Å–ª–æ
     * @param divisor –∫—Ä–∞—Ç–Ω–æ–µ —á–∏—Å–ª–æ
     * @return –∫—Ä–∞—Ç–Ω–æ?
     */
    public static boolean isMultiple(BigDecimal value, BigDecimal divisor) {
        logger.info("Is multiple param: value: {}, divisor: {}", value, divisor);
        boolean isMultiple = value.remainder(divisor).compareTo(BigDecimal.ZERO) == 0;
        logger.info("Is multiple? - {}", isMultiple);
        return isMultiple;
    }

    public static BigDecimal getPosSize(UserEntity user, Signal signal, TradeService service, BigDecimal entryPrice) {
        try {
            BigDecimal stopLoss = new BigDecimal(signal.getStopLoss());

            return service.calculatePositionSize(user, entryPrice, stopLoss, signal.getDirection());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}